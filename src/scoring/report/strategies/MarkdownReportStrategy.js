/**
 * Markdown Report Generation Strategy
 */

import { ReportStrategy } from './ReportStrategy.js';

export class MarkdownReportStrategy extends ReportStrategy {
  constructor() {
    super();
    this.format = 'markdown';
  }

  async generate(results, options = {}) {
    this.validateResults(results);

    const metadata = this.extractMetadata(results, options);
    const categories = this.formatCategories(results.categories);

    let markdown = this.generateHeader(metadata, results.overall);
    markdown += this.generateOverview(results.overall);
    markdown += this.generateCategoriesSection(categories);
    markdown += this.generateRecommendationsSection(results.recommendations || []);
    markdown += this.generateFooter(metadata);

    return markdown;
  }

  generateHeader(metadata, overall) {
    return `# 🎯 CodeFortify Quality Report

**Project:** ${metadata.projectName}  
**Generated:** ${new Date(metadata.timestamp).toLocaleString()}  
**Analysis Time:** ${metadata.analysisTime}ms  

---

`;
  }

  generateOverview(overall) {
    const percentage = Math.round(overall.percentage * 100);
    const description = this.getScoreDescription(overall.percentage);
    
    return `## 📊 Overall Score

**Score:** ${overall.score}/${overall.maxScore} (${percentage}%) - **Grade: ${overall.grade}**

${description}

---

`;
  }

  generateCategoriesSection(categories) {
    let section = `## 📋 Category Breakdown

| Category | Score | Grade | Issues |
|----------|-------|-------|---------|
`;

    for (const [key, category] of Object.entries(categories)) {
      const percentage = Math.round((category.score / category.maxScore) * 100);
      const issueCount = category.issues.length;
      section += `| ${category.name} | ${category.score}/${category.maxScore} (${percentage}%) | ${category.grade} | ${issueCount} |
`;
    }

    section += '\n### Category Details\n\n';
    
    for (const [key, category] of Object.entries(categories)) {
      section += `#### ${category.name}\n`;
      section += `**Score:** ${category.score}/${category.maxScore} (${Math.round((category.score / category.maxScore) * 100)}%) - Grade: ${category.grade}\n\n`;
      
      if (category.issues.length > 0) {
        section += '**Issues:**\n';
        category.issues.forEach(issue => {
          section += `- ⚠️ ${issue}\n`;
        });
        section += '\n';
      }
      
      if (category.suggestions.length > 0) {
        section += '**Suggestions:**\n';
        category.suggestions.forEach(suggestion => {
          section += `- 💡 ${suggestion}\n`;
        });
        section += '\n';
      }
    }

    return section + '---\n\n';
  }

  generateRecommendationsSection(recommendations) {
    if (!recommendations || recommendations.length === 0) {
      return `## 💡 Recommendations

No specific recommendations available.

---

`;
    }

    let section = `## 💡 Top Recommendations

`;

    recommendations.slice(0, 10).forEach((rec, index) => {
      const priority = this.getPriorityIcon(rec.priority);
      section += `### ${index + 1}. ${rec.title} ${priority}\n\n`;
      section += `${rec.description}\n\n`;
      section += `**Priority:** ${rec.priority} | **Impact:** ${rec.impact}/10 | **Effort:** ${rec.effort}\n\n`;
      
      if (rec.benefits && rec.benefits.length > 0) {
        section += '**Benefits:**\n';
        rec.benefits.forEach(benefit => {
          section += `- ✅ ${benefit}\n`;
        });
        section += '\n';
      }
      
      if (rec.commands && rec.commands.length > 0) {
        section += '**Commands:**\n';
        rec.commands.forEach(command => {
          section += `\`\`\`bash\n${command}\n\`\`\`\n`;
        });
        section += '\n';
      }
    });

    return section + '---\n\n';
  }

  generateFooter(metadata) {
    return `## 📝 Report Information

Generated by **CodeFortify** v${metadata.version}  
Timestamp: ${metadata.timestamp}  

[GitHub Repository](https://github.com/context7-mcp/codefortify)

*Continuous code quality improvement through AI-powered analysis*
`;
  }

  getPriorityIcon(priority) {
    switch (priority?.toLowerCase()) {
      case 'critical': return '🔴';
      case 'high': return '🟡';
      case 'medium': return '🟢';
      case 'low': return '🔵';
      default: return '⚪';
    }
  }

  getScoreDescription(percentage) {
    if (percentage >= 0.9) return "🎉 **Excellent code quality!**";
    if (percentage >= 0.8) return "👍 **Good quality with room for improvement**";
    if (percentage >= 0.7) return "⚖️ **Acceptable quality, focus on key areas**";
    if (percentage >= 0.6) return "⚠️ **Needs improvement in multiple areas**";
    return "🚨 **Significant quality issues require attention**";
  }

  getFileExtension() {
    return '.md';
  }

  getMimeType() {
    return 'text/markdown';
  }
}